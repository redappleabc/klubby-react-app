{"ast":null,"code":"var _objectSpread = require(\"/Users/admin/workspace/walletconnect-example-dapp/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _slicedToArray = require(\"/Users/admin/workspace/walletconnect-example-dapp/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar ethUtil = require('ethereumjs-util');\n\nvar ethAbi = require('ethereumjs-abi');\n\nvar nacl = require('tweetnacl');\n\nnacl.util = require('tweetnacl-util');\nvar TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string'\n            },\n            type: {\n              type: 'string'\n            }\n          },\n          required: ['name', 'type']\n        }\n      }\n    },\n    primaryType: {\n      type: 'string'\n    },\n    domain: {\n      type: 'object'\n    },\n    message: {\n      type: 'object'\n    }\n  },\n  required: ['types', 'primaryType', 'domain', 'message']\n};\n/**\n * A collection of utility functions used for signing typed data\n */\n\nvar TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData: function encodeData(primaryType, data, types) {\n    var _this = this;\n\n    var useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var encodedTypes = ['bytes32'];\n    var encodedValues = [this.hashType(primaryType, types)];\n\n    if (useV4) {\n      var encodeField = function encodeField(name, type, value) {\n        if (types[type] !== undefined) {\n          return ['bytes32', value === null || value === undefined ? '0x0000000000000000000000000000000000000000000000000000000000000000' : ethUtil.keccak(_this.encodeData(type, value, types, useV4))];\n        }\n\n        if (value === undefined) {\n          throw new Error(\"missing value for field \".concat(name, \" of type \").concat(type));\n        }\n\n        if (type === 'bytes') {\n          return ['bytes32', ethUtil.keccak(value)];\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8');\n          }\n\n          return ['bytes32', ethUtil.keccak(value)];\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          var parsedType = type.slice(0, type.lastIndexOf('['));\n          var typeValuePairs = value.map(function (item) {\n            return encodeField(name, parsedType, item);\n          });\n          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(typeValuePairs.map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 1),\n                _type = _ref2[0];\n\n            return _type;\n          }), typeValuePairs.map(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n                _value = _ref4[1];\n\n            return _value;\n          })))];\n        }\n\n        return [type, value];\n      };\n\n      var _iterator = _createForOfIteratorHelper(types[primaryType]),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n\n          var _encodeField = encodeField(field.name, field.type, data[field.name]),\n              _encodeField2 = _slicedToArray(_encodeField, 2),\n              type = _encodeField2[0],\n              value = _encodeField2[1];\n\n          encodedTypes.push(type);\n          encodedValues.push(value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else {\n      var _iterator2 = _createForOfIteratorHelper(types[primaryType]),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _field = _step2.value;\n          var _value2 = data[_field.name];\n\n          if (_value2 !== undefined) {\n            if (_field.type === 'bytes') {\n              encodedTypes.push('bytes32');\n              _value2 = ethUtil.keccak(_value2);\n              encodedValues.push(_value2);\n            } else if (_field.type === 'string') {\n              encodedTypes.push('bytes32'); // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n\n              if (typeof _value2 === 'string') {\n                _value2 = Buffer.from(_value2, 'utf8');\n              }\n\n              _value2 = ethUtil.keccak(_value2);\n              encodedValues.push(_value2);\n            } else if (types[_field.type] !== undefined) {\n              encodedTypes.push('bytes32');\n              _value2 = ethUtil.keccak(this.encodeData(_field.type, _value2, types, useV4));\n              encodedValues.push(_value2);\n            } else if (_field.type.lastIndexOf(']') === _field.type.length - 1) {\n              throw new Error('Arrays currently unimplemented in encodeData');\n            } else {\n              encodedTypes.push(_field.type);\n              encodedValues.push(_value2);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    return ethAbi.rawEncode(encodedTypes, encodedValues);\n  },\n\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType: function encodeType(primaryType, types) {\n    var result = '';\n    var deps = this.findTypeDependencies(primaryType, types).filter(function (dep) {\n      return dep !== primaryType;\n    });\n    deps = [primaryType].concat(deps.sort());\n\n    var _iterator3 = _createForOfIteratorHelper(deps),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var type = _step3.value;\n        var children = types[type];\n\n        if (!children) {\n          throw new Error(\"No type definition specified: \".concat(type));\n        }\n\n        result += \"\".concat(type, \"(\").concat(types[type].map(function (_ref5) {\n          var name = _ref5.name,\n              _type = _ref5.type;\n          return \"\".concat(_type, \" \").concat(name);\n        }).join(','), \")\");\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return result;\n  },\n\n  /**\n   * Finds all types within a type defintion object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies: function findTypeDependencies(primaryType, types) {\n    var results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    var _primaryType$match = primaryType.match(/^[0-9A-Z_a-z]*/),\n        _primaryType$match2 = _slicedToArray(_primaryType$match, 1),\n        firstWord = _primaryType$match2[0];\n\n    primaryType = firstWord;\n\n    if (results.includes(primaryType) || types[primaryType] === undefined) {\n      return results;\n    }\n\n    results.push(primaryType);\n\n    var _iterator4 = _createForOfIteratorHelper(types[primaryType]),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var field = _step4.value;\n\n        var _iterator5 = _createForOfIteratorHelper(this.findTypeDependencies(field.type, types, results)),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var dep = _step5.value;\n            !results.includes(dep) && results.push(dep);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return results;\n  },\n\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashStruct: function hashStruct(primaryType, data, types) {\n    var useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4));\n  },\n\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType: function hashType(primaryType, types) {\n    return ethUtil.keccak(this.encodeType(primaryType, types));\n  },\n\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData: function sanitizeData(data) {\n    var sanitizedData = {};\n\n    for (var _i = 0, _Object$keys = Object.keys(TYPED_MESSAGE_SCHEMA.properties); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n      data[key] && (sanitizedData[key] = data[key]);\n    }\n\n    if (sanitizedData.types) {\n      sanitizedData.types = _objectSpread({\n        EIP712Domain: []\n      }, sanitizedData.types);\n    }\n\n    return sanitizedData;\n  },\n\n  /**\n   * Signs a typed message as per EIP-712 and returns its keccak hash\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - keccak hash of the resulting signed message\n   */\n  sign: function sign(typedData) {\n    var useV4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var sanitizedData = this.sanitizeData(typedData);\n    var parts = [Buffer.from('1901', 'hex')];\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));\n\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));\n    }\n\n    return ethUtil.keccak(Buffer.concat(parts));\n  }\n};\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA: TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils: TypedDataUtils,\n  concatSig: function concatSig(v, r, s) {\n    var rSig = ethUtil.fromSigned(r);\n    var sSig = ethUtil.fromSigned(s);\n    var vSig = ethUtil.bufferToInt(v);\n    var rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64);\n    var sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64);\n    var vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));\n    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex');\n  },\n  normalize: function normalize(input) {\n    if (!input) {\n      return undefined;\n    }\n\n    if (typeof input === 'number') {\n      var buffer = ethUtil.toBuffer(input);\n      input = ethUtil.bufferToHex(buffer);\n    }\n\n    if (typeof input !== 'string') {\n      var msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n      msg += \" received \".concat(typeof input, \": \").concat(input);\n      throw new Error(msg);\n    }\n\n    return ethUtil.addHexPrefix(input.toLowerCase());\n  },\n  personalSign: function personalSign(privateKey, msgParams) {\n    var message = ethUtil.toBuffer(msgParams.data);\n    var msgHash = ethUtil.hashPersonalMessage(message);\n    var sig = ethUtil.ecsign(msgHash, privateKey);\n    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n    return serialized;\n  },\n  recoverPersonalSignature: function recoverPersonalSignature(msgParams) {\n    var publicKey = getPublicKeyFor(msgParams);\n    var sender = ethUtil.publicToAddress(publicKey);\n    var senderHex = ethUtil.bufferToHex(sender);\n    return senderHex;\n  },\n  extractPublicKey: function extractPublicKey(msgParams) {\n    var publicKey = getPublicKeyFor(msgParams);\n    return \"0x\".concat(publicKey.toString('hex'));\n  },\n  typedSignatureHash: function typedSignatureHash(typedData) {\n    var hashBuffer = _typedSignatureHash(typedData);\n\n    return ethUtil.bufferToHex(hashBuffer);\n  },\n  signTypedDataLegacy: function signTypedDataLegacy(privateKey, msgParams) {\n    var msgHash = _typedSignatureHash(msgParams.data);\n\n    var sig = ethUtil.ecsign(msgHash, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  recoverTypedSignatureLegacy: function recoverTypedSignatureLegacy(msgParams) {\n    var msgHash = _typedSignatureHash(msgParams.data);\n\n    var publicKey = recoverPublicKey(msgHash, msgParams.sig);\n    var sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  },\n  encrypt: function encrypt(receiverPublicKey, msgParams, version) {\n    switch (version) {\n      case 'x25519-xsalsa20-poly1305':\n        {\n          if (typeof msgParams.data === 'undefined') {\n            throw new Error('Cannot detect secret message, message params should be of the form {data: \"secret message\"} ');\n          } // generate ephemeral keypair\n\n\n          var ephemeralKeyPair = nacl.box.keyPair(); // assemble encryption parameters - from string to UInt8\n\n          var pubKeyUInt8Array;\n\n          try {\n            pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey);\n          } catch (err) {\n            throw new Error('Bad public key');\n          }\n\n          var msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data);\n          var nonce = nacl.randomBytes(nacl.box.nonceLength); // encrypt\n\n          var encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey); // handle encrypted data\n\n          var output = {\n            version: 'x25519-xsalsa20-poly1305',\n            nonce: nacl.util.encodeBase64(nonce),\n            ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),\n            ciphertext: nacl.util.encodeBase64(encryptedMessage)\n          }; // return encrypted msg data\n\n          return output;\n        }\n\n      default:\n        throw new Error('Encryption type/version not supported');\n    }\n  },\n  encryptSafely: function encryptSafely(receiverPublicKey, msgParams, version) {\n    var DEFAULT_PADDING_LENGTH = Math.pow(2, 11);\n    var NACL_EXTRA_BYTES = 16;\n    var data = msgParams.data;\n\n    if (!data) {\n      throw new Error('Cannot encrypt empty msg.data');\n    }\n\n    if (typeof data === 'object' && data.toJSON) {\n      // remove toJSON attack vector\n      // TODO, check all possible children\n      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n    } // add padding\n\n\n    var dataWithPadding = {\n      data: data,\n      padding: ''\n    }; // calculate padding\n\n    var dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n    var modVal = dataLength % DEFAULT_PADDING_LENGTH;\n    var padLength = 0; // Only pad if necessary\n\n    if (modVal > 0) {\n      padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n    }\n\n    dataWithPadding.padding = '0'.repeat(padLength);\n    var paddedMsgParams = {\n      data: JSON.stringify(dataWithPadding)\n    };\n    return this.encrypt(receiverPublicKey, paddedMsgParams, version);\n  },\n  decrypt: function decrypt(encryptedData, receiverPrivateKey) {\n    switch (encryptedData.version) {\n      case 'x25519-xsalsa20-poly1305':\n        {\n          // string to buffer to UInt8Array\n          var recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey);\n          var recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey; // assemble decryption parameters\n\n          var nonce = nacl.util.decodeBase64(encryptedData.nonce);\n          var ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext);\n          var ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey); // decrypt\n\n          var decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey); // return decrypted msg data\n\n          var output;\n\n          try {\n            output = nacl.util.encodeUTF8(decryptedMessage);\n          } catch (err) {\n            throw new Error('Decryption failed.');\n          }\n\n          if (output) {\n            return output;\n          }\n\n          throw new Error('Decryption failed.');\n        }\n\n      default:\n        throw new Error('Encryption type/version not supported.');\n    }\n  },\n  decryptSafely: function decryptSafely(encryptedData, receiverPrivateKey) {\n    var dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey));\n    return dataWithPadding.data;\n  },\n  getEncryptionPublicKey: function getEncryptionPublicKey(privateKey) {\n    var privateKeyUint8Array = nacl_decodeHex(privateKey);\n    var encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n    return nacl.util.encodeBase64(encryptionPublicKey);\n  },\n\n  /**\n   * A generic entry point for all typed data methods to be passed, includes a version parameter.\n   */\n  signTypedMessage: function signTypedMessage(privateKey, msgParams) {\n    var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'V4';\n\n    switch (version) {\n      case 'V1':\n        return this.signTypedDataLegacy(privateKey, msgParams);\n\n      case 'V3':\n        return this.signTypedData(privateKey, msgParams);\n\n      case 'V4':\n      default:\n        return this.signTypedData_v4(privateKey, msgParams);\n    }\n  },\n  recoverTypedMessage: function recoverTypedMessage(msgParams) {\n    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'V4';\n\n    switch (version) {\n      case 'V1':\n        return this.recoverTypedSignatureLegacy(msgParams);\n\n      case 'V3':\n        return this.recoverTypedSignature(msgParams);\n\n      case 'V4':\n      default:\n        return this.recoverTypedSignature_v4(msgParams);\n    }\n  },\n  signTypedData: function signTypedData(privateKey, msgParams) {\n    var message = TypedDataUtils.sign(msgParams.data, false);\n    var sig = ethUtil.ecsign(message, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  signTypedData_v4: function signTypedData_v4(privateKey, msgParams) {\n    var message = TypedDataUtils.sign(msgParams.data);\n    var sig = ethUtil.ecsign(message, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  recoverTypedSignature: function recoverTypedSignature(msgParams) {\n    var message = TypedDataUtils.sign(msgParams.data, false);\n    var publicKey = recoverPublicKey(message, msgParams.sig);\n    var sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  },\n  recoverTypedSignature_v4: function recoverTypedSignature_v4(msgParams) {\n    var message = TypedDataUtils.sign(msgParams.data);\n    var publicKey = recoverPublicKey(message, msgParams.sig);\n    var sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  }\n};\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\n\nfunction _typedSignatureHash(typedData) {\n  var error = new Error('Expect argument to be non-empty array');\n\n  if (typeof typedData !== 'object' || !typedData.length) {\n    throw error;\n  }\n\n  var data = typedData.map(function (e) {\n    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value;\n  });\n  var types = typedData.map(function (e) {\n    return e.type;\n  });\n  var schema = typedData.map(function (e) {\n    if (!e.name) {\n      throw error;\n    }\n\n    return \"\".concat(e.type, \" \").concat(e.name);\n  });\n  return ethAbi.soliditySHA3(['bytes32', 'bytes32'], [ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema), ethAbi.soliditySHA3(types, data)]);\n}\n\nfunction recoverPublicKey(hash, sig) {\n  var signature = ethUtil.toBuffer(sig);\n  var sigParams = ethUtil.fromRpcSig(signature);\n  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);\n}\n\nfunction getPublicKeyFor(msgParams) {\n  var message = ethUtil.toBuffer(msgParams.data);\n  var msgHash = ethUtil.hashPersonalMessage(message);\n  return recoverPublicKey(msgHash, msgParams.sig);\n}\n\nfunction padWithZeroes(number, length) {\n  var myString = \"\".concat(number);\n\n  while (myString.length < length) {\n    myString = \"0\".concat(myString);\n  }\n\n  return myString;\n} // converts hex strings to the Uint8Array format used by nacl\n\n\nfunction nacl_decodeHex(msgHex) {\n  var msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return nacl.util.decodeBase64(msgBase64);\n}","map":null,"metadata":{},"sourceType":"script"}